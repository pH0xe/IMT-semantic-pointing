import * as THREE from "three";

export const generateCross = (
  scale,
  translateX,
  translateY,
  translateZ,
  rotateX,
  rotateY,
  rotateZ,
  color = 0xffffff
) => {
  const depth = 0.5;
  const rear = 1 - depth;
  const geometry = new THREE.BufferGeometry();
  const frontCross = crossCoords.flatMap((t) => t.flatMap((p) => [...p, rear]));
  const backCross = crossCoords.flatMap((t) =>
    t.reverse().flatMap((p) => [...p, 1])
  );

  const vertices = new Float32Array([
    ...frontCross,
    ...backCross,
    3,
    4,
    rear,
    3,
    1,
    1,
    3,
    1,
    rear,
    3,
    4,
    rear,
    3,
    4,
    1,
    3,
    1,
    1,
    3,
    4,
    rear,
    4,
    4,
    rear,
    4,
    4,
    1,
    3,
    4,
    rear,
    4,
    4,
    1,
    3,
    4,
    1,
    4,
    5,
    rear,
    4,
    5,
    1,
    4,
    4,
    1,
    4,
    5,
    rear,
    4,
    4,
    1,
    4,
    4,
    rear,
    3,
    5,
    rear,
    4,
    5,
    1,
    4,
    5,
    rear,
    3,
    5,
    rear,
    3,
    5,
    1,
    4,
    5,
    1,
    3,
    6,
    rear,
    3,
    5,
    1,
    3,
    5,
    rear,
    3,
    6,
    rear,
    3,
    6,
    1,
    3,
    5,
    1,
    3,
    6,
    rear,
    2,
    6,
    1,
    3,
    6,
    1,
    3,
    6,
    rear,
    2,
    6,
    rear,
    2,
    6,
    1,
    2,
    6,
    1,
    2,
    6,
    rear,
    2,
    5,
    rear,
    2,
    6,
    1,
    2,
    5,
    rear,
    2,
    5,
    1,
    2,
    5,
    1,
    2,
    5,
    rear,
    1,
    5,
    rear,
    2,
    5,
    1,
    1,
    5,
    rear,
    1,
    5,
    1,
    1,
    5,
    1,
    1,
    5,
    rear,
    1,
    4,
    rear,
    1,
    5,
    1,
    1,
    4,
    rear,
    1,
    4,
    1,
    1,
    4,
    1,
    1,
    4,
    rear,
    2,
    4,
    rear,
    1,
    4,
    1,
    2,
    4,
    rear,
    2,
    4,
    1,
    2,
    4,
    1,
    2,
    4,
    rear,
    2,
    1,
    rear,
    2,
    4,
    1,
    2,
    1,
    rear,
    2,
    1,
    1,
    2,
    1,
    1,
    2,
    1,
    rear,
    3,
    1,
    rear,
    2,
    1,
    1,
    3,
    1,
    rear,
    3,
    1,
    1,
  ]);

  geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({ color });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.scale.set(scale, scale, scale);
  mesh.translateX(translateX);
  mesh.translateY(translateY);
  mesh.translateZ(translateZ);
  mesh.rotation.set(rotateX, rotateY, rotateZ);
  return mesh;
};

const random = (min, max) => Math.random() * (max - min) + min;

export const generateCrosses = (count, godMode) => {
  const crosses = [];
  for (let i = 0; i < count; i++) {
    const translateZ = random(-100, -10);
    // plus on est loin plus l'intervalle x et y est grand
    const translateX = random(-translateZ / 2, translateZ / 2);
    const translateY = random(-translateZ / 2, translateZ / 2);
    crosses.push(
      generateCross(
        1,
        translateX,
        translateY,
        translateZ,
        0,
        0,
        0,
        godMode ? 0x6c5ce7 : 0xffffff
      )
    );
  }

  return crosses;
};

const crossCoords = [
  [
    [2, 1],
    [3, 6],
    [3, 1],
  ],
  [
    [2, 1],
    [2, 6],
    [3, 6],
  ],
  [
    [1, 5],
    [2, 5],
    [2, 4],
  ],
  [
    [1, 5],
    [2, 4],
    [1, 4],
  ],
  [
    [3, 5],
    [4, 4],
    [3, 4],
  ],
  [
    [3, 5],
    [4, 5],
    [4, 4],
  ],
];
